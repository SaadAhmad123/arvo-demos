import { cleanString } from '../../../../../../utils';
import type { DemoCodePanel } from '../../../../../types';

export const ResumableContract: DemoCodePanel = {
  heading: 'The Contract',
  description: cleanString(`
    Like all Arvo components, \`ArvoResumable\` is just an event handler bound to a contract. 
    It uses the contract definition generated by \`createArvoOrchestratorContract\`, the same 
    as \`ArvoMachine\` and \`ArvoOrchestrator\`, because resumables serve the same architectural 
    role as state machine based orchestrators. Both coordinate workflows, both consume init events 
    and emit complete events, and both need the same contract structure. The only difference is 
    how they implement the orchestration logic internally. Using the same contract type means 
    resumables and state machines are interchangeable from the system's perspective.

    This weighted average calculator demonstrates dynamic orchestration where the workflow 
    adapts at runtime. It requests human approval before processing, then emits parallel 
    calculation events based on the input array length (3 items means 3 events, 100 items 
    means 100 events). After aggregating results, it calculates and returns the final 
    average. This is pedagogical overkill for a simple calculation, but it shows you the 
    patterns for coordinating human approvals, parallel processing, and multi-step workflows 
    in a clear, contained example.
  `),
  tabs: [
    {
      title: 'resumable.demo/contract.ts',
      lang: 'ts',
      code: `
import {
  createArvoOrchestratorContract,
  cleanString,
} from 'arvo-core';
 import z from 'zod';

/**
 * Contract Definition for Weighted Average Orchestration
 */
export const weightedAverageContract = createArvoOrchestratorContract({
  uri: '#/org/amas/resumable/weighted_average',
  name: 'weighted.average',
  description: cleanString(\`
    A service which calculates the weighted average of the input
  \`),
  versions: {
    '1.0.0': {
      init: z.object({
        input: z.object({
          value: z.number(),
          weight: z.number().min(0).max(1),
        }).array().min(1),
      }),
      complete: z.object({
        output: z.number().nullable(),
      }),
    },
  },
});
`,
    },
  ],
};
