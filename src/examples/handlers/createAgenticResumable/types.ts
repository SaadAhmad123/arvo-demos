import type { InferVersionedArvoContract } from 'arvo-core';
import type { Span } from '@opentelemetry/api';
import type { VersionedArvoContract } from 'arvo-core';
import { z } from 'zod';

// biome-ignore lint/suspicious/noExplicitAny: Needs to be general
export type AnyVersionedContract = VersionedArvoContract<any, any>;

/**
 * Message content representing the result of a completed tool execution.
 *
 * Used when an LLM receives the output from a previously requested tool call.
 * The content is typically JSON-serialized data from the tool's execution.
 */
export const AgenticToolResultMessageContentSchema = z.object({
  type: z.literal('tool_result'),
  /** Unique identifier linking this result back to the original tool request */
  tool_use_id: z.string(),
  /** JSON-serialized output data returned by the executed tool */
  content: z.string(),
});

export type AgenticToolResultMessageContent = z.infer<typeof AgenticToolResultMessageContentSchema>;

/**
 * Message content representing a request to execute a specific tool.
 *
 * Generated by LLMs when they determine a tool call is needed to fulfill
 * a user request. Contains all necessary parameters for tool execution.
 */
export const AgenticToolCallMessageContentSchema = z.object({
  type: z.literal('tool_use'),
  /** Unique identifier for tracking this specific tool request */
  id: z.string(),
  /** Name/type of the tool to execute (maps to Arvo service contract types) */
  name: z.string(),
  /** Parameters to pass to the tool, structured according to the tool's contract */
  input: z.object({}).passthrough(), // Allows any object structure
});

export type AgenticToolCallMessageContent = z.infer<typeof AgenticToolCallMessageContentSchema>;

/**
 * Message content containing plain text communication.
 *
 * Represents standard conversational content without any tool interaction.
 * Used for both user input and LLM text responses.
 */
export const AgenticTextMessageContentSchema = z.object({
  type: z.literal('text'),
  /** The actual text content of the message */
  content: z.string(),
});

export type AgenticTextMessageContent = z.infer<typeof AgenticTextMessageContentSchema>;

// Union schema for all message content types
export const AgenticMessageContentSchema = z.discriminatedUnion('type', [
  AgenticToolResultMessageContentSchema,
  AgenticToolCallMessageContentSchema,
  AgenticTextMessageContentSchema,
]);

export type AgenticMessageContent = z.infer<typeof AgenticMessageContentSchema>;

/**
 * Input parameters for calling an agentic LLM service.
 *
 * Provides the LLM with conversation context, available tools, and prompt templates
 * to generate appropriate responses or tool requests.
 */
export type CallAgenticLLMParam<
  TTools extends Record<string, AnyVersionedContract> = Record<string, AnyVersionedContract>,
  // biome-ignore lint/suspicious/noExplicitAny: Needs to general
  TPrompts extends Record<string, (...args: any[]) => string> = Record<string, (...args: any[]) => string>,
  TOutput extends z.AnyZodObject = z.AnyZodObject,
> = {
  /**
   * Indicates whether this is conversation initialization or processing tool results.
   * - 'init': Start of conversation with user message
   * - 'tool_results': Continuation after receiving tool execution results
   */
  type: 'init' | 'tool_results';

  /**
   * Complete conversation history in chronological order.
   */
  messages: {
    role: 'user' | 'assistant';
    content: AgenticMessageContent[];
  }[];

  /**
   * Available tools/services the LLM can invoke.
   *
   * Each tool is defined by its Arvo contract, providing schema validation
   * and type safety for tool parameter generation.
   */
  tools: TTools;

  /** Collection of prompt template functions for different conversation scenarios */
  prompts: TPrompts;

  /** The current OTEL span to record logs to. */
  span: Span;

  /**
   * The final output format of the LLM. If this is defined then LLM must return
   * the JSON formated object otherwise the response must be a string
   */
  outputFormat?: TOutput;
};

/**
 * Response from an agentic LLM service call.
 *
 * The LLM can either provide a direct text response or request tool executions.
 * These are mutually exclusive - if tool requests are present, response must be null.
 *
 * @template TTools - Mapping of tool names to their Arvo contract definitions
 */
export type CallAgenticLLMOutput<
  TTools extends Record<string, AnyVersionedContract> = Record<string, AnyVersionedContract>,
> = {
  /**
   * Tool execution requests generated by the LLM.
   *
   * Each request is fully typed according to its corresponding Arvo contract,
   * ensuring type safety between LLM tool selection and service execution.
   * Null when the LLM provides a direct text response instead.
   */
  toolRequests: Array<
    {
      [K in keyof TTools]: {
        type: InferVersionedArvoContract<TTools[K]>['accepts']['type'];
        data: InferVersionedArvoContract<TTools[K]>['accepts']['data'];
        id: string;
      };
    }[keyof TTools]
  > | null;

  /**
   * Direct text response from the LLM.
   *
   * Present when the LLM can fulfill the request without tool usage.
   * Must be null when toolRequests are present.
   */
  response: string | object | null;

  /**
   * Count of each tool type requested in this call.
   *
   * Used for tracking tool usage patterns, debugging, and ensuring
   * all expected tool responses are collected before proceeding.
   */
  toolTypeCount: Record<string, number>;

  usage?: {
    tokens: {
      prompt: number;
      completion: number;
    };
  };
};

/**
 * Function signature for calling an agentic LLM service.
 *
 * Implementations should handle the conversation context, tool definitions,
 * and return either a text response or structured tool requests.
 */
export type CallAgenticLLM<
  TTools extends Record<string, AnyVersionedContract> = Record<string, AnyVersionedContract>,
  // biome-ignore lint/suspicious/noExplicitAny: Needs to be general
  TPrompts extends Record<string, (...args: any[]) => string> = Record<string, (...args: any[]) => string>,
  TOutput extends z.AnyZodObject = z.AnyZodObject,
> = (param: CallAgenticLLMParam<TTools, TPrompts, TOutput>) => Promise<CallAgenticLLMOutput<TTools>>;

/**
 * Configuration parameters for creating an agentic resumable orchestrator.
 *
 * Defines all components needed to create an AI agent that can engage in
 * conversations, make tool decisions, and execute workflows through Arvo's
 * event-driven architecture.
 */
export type CreateAgenticResumableParams<
  TName extends string,
  TServices extends Record<string, AnyVersionedContract> = Record<string, AnyVersionedContract>,
  // biome-ignore lint/suspicious/noExplicitAny: Needs to general
  TPrompts extends Record<string, (...args: any[]) => string> = Record<string, (...args: any[]) => string>,
  TOutput extends z.AnyZodObject = z.AnyZodObject,
> = {
  /**
   * Unique name for this agent instance.
   * Used in generated contract URIs and for agent identification.
   */
  name: TName;

  /**
   * Function implementing the LLM service integration.
   */
  agenticLLMCaller: CallAgenticLLM<TServices, TPrompts, TOutput>;

  /**
   * A zod object defining the type of the output object
   */
  outputFormat?: TOutput;

  /**
   * Arvo service contracts available as tools for the agent.
   *
   * Each contract defines a service the LLM can invoke, with full
   * type safety and schema validation enforced by Arvo.
   */
  services?: TServices;

  /**
   * Optional domain routing configuration for services.
   *
   * Maps service event types to specific processing domains,
   * enabling advanced routing patterns
   */
  serviceDomains?: Record<{ [K in keyof TServices]: TServices[K]['accepts']['type'] }[keyof TServices], string[]>;

  /**
   * Prompt template functions for different conversation scenarios.
   *
   * Provides reusable prompt generation for system messages,
   * tool descriptions, and context-specific instructions.
   */
  prompts?: TPrompts;
};
